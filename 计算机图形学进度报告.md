<font face="楷体">

## 《计算机图形学》10月报告

##### 王嘉豪 201220162

**(南京大学 计算机科学与技术系， 南京 210093)**

- **1 引言**

  本实习作业采用助教给出的 `CG_Demo` 作为框架，并在其基础上逐步实现画图和修改图形等算法，最后能够处理输入的命令和UI操作来画出想要的简单图形

- **2.1 已实现内容及思路、算法等**

  - ==DDA算法绘制线段==

    比较简单的画线方法，判断斜率绝对值是否大于1来确定以x或是y作为增量，从而使像素点数量更多

  - ==Bresenham算法绘制线段==

    引入决策参数$p_k$，用于决定选高/低像素点。选择时也要区分斜率大于/小于1的情况，小于1时取$\Delta x = 1$， 反之取$\Delta y = 1$；

    以 $abs(斜率) < 1$ 的情况为例：$p_{k+1} - p_k = 2\Delta y(x_{k+1} - x_k) - 2\Delta x(y_{k+1}-y_k)$，$p_k > 0$ 时 $y_{k+1} = y_k+1$ (取高像素)，$p_{k+1} = p_k + 2\Delta y-2\Delta x$， 否则$y_{k+1} = y_k$(取低像素)，$p_{k+1} = p_k + 2\Delta y$

  - ==中点椭圆生成算法绘制椭圆==

    **·** 椭圆函数为 $f_{ellipse}(x, y)={r_y}^2x^2+{r_x}^2y^2-{r_x}^2{r_y}^2$，对于不同的 $(x, y)$ 有以下性质：

    $ \left \{ \begin{aligned} f_{ellipse}(x,y)<0,(x,y)\ 位于椭圆周边界内 \\ f_{ellipse}(x,y)=0,(x,y)\ 位于椭圆周边界上 \\f_{ellipse}(x,y)>0,(x,y)\ 位于椭圆周边界外 \end{aligned} \right.$

    假设椭圆中心位于原点处，$r_x > r_y$，则可将其分为两个区域：切线斜率绝对值小于1(区域一)和大于1(区域二)，理由同上述直线

    **·** 第一象限分界点满足 $dy/dx=-1$，即 $2{r_y}^2x = 2{r_x}^2y$，可从 $(0, r_y)$ 处开始以 $\Delta x=1$ 移动直到 $2{r_y}^2x \geq 2{r_x}^2y$ 

    **·** $决策参数\ p1_k=f_{ellipse}(x_{k+1}, y_k-\frac{1}{2})={r_y}^2(x_k+1)^2+{r_x}^2(y_k-\frac{1}{2})^2-{r_x}^2{r_y}^2$ 

    若 $p1_k < 0$，中点在椭圆内，选择高像素点 $y_k$，否则选低像素点 $y_{k-1}$，故下一步决策参数如下：

    $\left \{ \begin{aligned} p1_{k+1}=p1_k+2{r_y}^2x_k+3{r_y}^2,\ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ p1_k<0 \\p1_{k+1} =p1_k+2{r_y}^2x_k-2{r_x}^2y_k+2{r_x}^2+3{r_y}^2, p1_k \geq0\end{aligned} \right.$

    当 $切线斜率<-1$ 时，以上述过程的最后一个点作为新区域的起点 $(x0, y0)$，此时 $\Delta y=1$

    **·** $决策参数p2_k=f_{ellipse}(x_k+\frac{1}{2},y_k-1)={r_y}^2(x_k+\frac{1}{2})^2+{r_x}^2(y_k-1)^2-{r_x}^2{r_y}^2$

    若 $p2_k \leq 0$，中点在椭圆内，选择像素点 $x_{k+1}$，否则选像素点 $x_k$，故下一步决策参数如下(教材上判断条件写反了)：

    $\left \{ \begin{aligned} p2_{k+1}=p2_k-2{r_x}^2y_k+3{r_x}^2,\ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ p2_k>0 \\ p2_{k+1} =p2_k+2{r_y}^2x_k-2{r_x}^2y_k+2{r_y}^2+3{r_x}^2, p2_k \leq0\end{aligned} \right.$

    **·** 实现算法时只需区分长短轴分别在 $x/y$ 轴上的情况，在生成一个象限的点后其他象限可对称生成，最后为每个点加上 $(\cfrac{x_0+x_1}{2},\cfrac{y_0+y_1}{2})$ 作为偏移量

  - ==中点圆生成算法绘制圆==

    同样采用中点椭圆生成算法

    第一个 `mousePressEvent` 是圆心的位置，随后 `mouseMoveEvent` 决定圆的半径，`mouseRealeaseEvent` 结束绘图

  - ==图元平移==

    只需将每个点的横纵坐标依次加上 $\Delta x、\Delta y$ 即可

  - ==图元旋转==

    **·** 当基准点为坐标原点时，二维旋转变换方程为：

    $\left \{ \begin{aligned} x_2=x_1cos\theta-y_1sin\theta \\ y_2=x1sin\theta+y_1cos\theta \end{aligned} \right.$

    **·** 可先将每个点的坐标减去旋转中心，将基准点变为原点后完成旋转，最后将偏移量加回

    `Python` 的 $sin/cos$ 函数以弧度制作为输入，使用时需将角度转为弧度

  - ==图元缩放==

    缩放中心点到图像各点的坐标差值乘缩放倍数即是新点的坐标，也可以先算出新点对于旧点的偏移量如下

    ~~~
    delta_x = (p_list[i][0] - x) * (s - 1)  #(x, y)为缩放中心，s为缩放倍数
    delta_y = (p_list[i][1] - y) * (s - 1)
    ~~~

    最后为旧点加上偏移量

  - ==Cohen-Sutherland算法裁剪线段==

    **·** 以裁剪窗口为中心，加上其周围八个方向的窗口，对这九个窗口采用四位“区域码”，从而确定线段端点的相对位置

    规则如下：

    ~~~ 
                          |                               |
            1001          |             1000              |     1010
            Ymax          |                               |
    -----------------------------------------------------------------------
                          |                               |
            0001          |       	    0000              |     0010
            Ymin          |            window             |
    -----------------------------------------------------------------------
    					  |                               |
            0101          |             0100              |     0110
                          |                               |
                         Xmin                            Xmax
    ~~~

    **·** 若两端点区域码均为 $0000$，则线段完全处于裁剪窗口内

    **·** 若两端点区域码相与之后结果不为 $0000$，则线段完全处于窗口外，舍弃

    其他情况均需要求线段和窗口的交

    **·** 仅当两区域码的同一位不相同时，线段才可能在对应边界上存在交点，即：

    $(flag1 \oplus flag2) == 1/2/4/8$ 时，分别在 $x_{min}/x_{max}/y_{min}/y_{max}$ 处求交点，可按照上下右左的顺序检查是否在边界上存在交点，存在交点时更新窗口外部端点的 $(x, y)$，最后留下的部分即为裁剪得到的线段

  - ==Liang-Barsky算法裁剪线段==

    **·** `Liang-Barsky` 算法将二维裁剪转化为一维裁剪，设两端点分别为 $(x_0,y_0),(x_1,y_1)$，则线段上一点 $(x, y)$ 可表示为：

    $\left \{ \begin{aligned} x=x_0+\mu(x_1-x_0)=x_0+\mu \Delta x \\y=y_0+\mu(y_1-y_0)=y_0+\mu\Delta y \ \ \end{aligned} \right.$

    其中 $\mu \in[0,1]$

    要求得在裁剪窗口内的部分，则上式需满足：

    $\left \{ \begin{aligned} &x{\omega}_{min}\leq x_0+\mu \Delta x \leq x{\omega}_{max} \\ &y{\omega}_{min} \leq y_0+\mu\Delta y\leq y{\omega}_{max} \ \end{aligned} \right.$

    上式可统一表示为 $\mu*p_k \leq q_k$，其中 $k=1,2,3,4$，对应裁剪窗口的左右上下边界，$p、q$ 定义为：

    $\left \{ \begin{aligned} &p_1=-\Delta x,q_1=x_0-x{\omega}_{min} \\ &p_2=\Delta x,q_2=x{\omega}_{max}-x_1\\ &p_3=-\Delta y,q_3=y_0-y{\omega}_{min} \\ &p_4=\Delta y,q_4=y{\omega}_{max}-y_1\end{aligned} \right.$

    (教材符号又反了)

    **·** 若任意 $p_k=0$，则线段所在直线平行于裁剪窗口之一；若同时 $q_k <0$，则线段完全在边界外，否则在窗口内

    故当 $p_k$ 非零时，可计算线段与边界 $k$ 交点的 $\mu$ 值：$\mu =q_k/p_k$

    对每条线段计算参数 $\mu_1 、\mu_2$，$\mu_1$ 的值由线段从外到内遇到的矩形边界所决定($p<0$)，$\mu_2$ 的值由线段从内到外遇到的矩形边界所决定($p>0$)

    对每个边界计算参数$r_k=q_k/p_k$，$p<0$ 时 $\mu1$ 取 $0$ 和各个 $r_k$ 间的最大值，$\mu_2$ 取 $1$ 和各个 $r_k$ 之间的最小值

    若在任意一次更新后 $\mu_1>\mu_2$，则需要舍弃该线段，否则保留 $\mu_1、\mu_2$ 进行后续计算

    在进行四次更新后若线段仍未被舍弃，则可以用下式求出最终两点坐标：

    ~~~
    if mu2 < 1:
        x1 = x0 + mu2 * delta_x
        y1 = y0 + mu2 * delta_y
    if mu1 > 0:
        x0 = x0 + mu1 * delta_x
        y0 = y0 + mu1 * delta_y
    ~~~

    $(x_0,y_0),(x_1,y_1)$ 为截取后线段端点坐标

    `Liang-Barsky` 算法相比 `Cohen-Sutherland` 算法效率更高，因为只在计算 $\mu_1、\mu_2$ 时使用除法

  - ==Bezier曲线生成==

    **·** `Bernstein` 基函数的多项式形式为 $BEZ_{i,n}(u)=C(n,i)u^i(1-u)^{n-i}$，其中 $C(n,i)$ 为组合数

    **·** `Bernstein` 基函数拥有若干性质，其中需要用到的主要是降阶公式，即一个 $n$ 次 `Bernstein` 基函数能表示成两个 $n-1$ 次基函数的线性和：

    $BEZ_{i,n}(u)=(1-u)BEZ_{i,n-1}(u)+uBEZ_{i-1,n-1}(u),\ \ \ \ \ i=(0,1,2,...,n)$

    **·** 假设对 `Bezier` 曲线给出了 $n+1$ 个控制顶点的位置，这些坐标点混合产生了位置向量 $P(u)$，用来描述 $P_0$ 和 $P_n$ 间的逼近 `Bezier` 多项式函数的曲线：

    $P(u)=\sum \limits_{i=0}^nP_iBEZ_{i,n}(u)$

    其中，混合函数 $BEZ_{i,n}(u)$ 是 $n$ 次 `Bernstein` 多项式

    **·** 在给定任意参数 $u$ 的情况下，计算某阶曲线上对应点的坐标可以直接使用曲线方程或矩阵来计算，但该方法不通用且计算量很大。于是可以采用德卡斯特里奥`(de Casteljau)` 递推算法来计算曲线上的点。该算法描述了直接利用控制多边形顶点从参数 $u$ 计算 $n$ 次 `Bezier` 曲线型值点 $P(u)$ 的过程，对于某一特定的参数 $u$，其计算公式为：

    $P_i^r=\left \{ \begin{aligned} &P_i,\ \ \ \ r=0\\&(1-u)P_i^{r-1}+uP_{i+1}^{r-1},\ \ \ r=1,2,...,n;\ \ i=0,1,2,...,n-t \end{aligned} \right.$

    即 $r=0$ 时，计算结果为控制顶点本身，而曲线上的型值点为 $P(u)=P_0^n$

    **·** 代码实现时仅额外定义一个递归函数 `deCasteljau_x(r, i, u, p_list)`，其中 `r` 初值为控制顶点数量 $-1$，`i` 初值为 $0$，`u` 初值为 `k/准备画的点的总数(k表示已经画到第k个点)`，`p_list` 则保存控制顶点的坐标

  - ==B-spline曲线生成==

    **·** `B-spline` 基函数：给定参数 u 轴上的节点分割：$U_{n,k}=\{u_i\}(i=0,1,2,...,n+k)$ ，称由下列 `deBoox-Cox` 递推关系所确定的 $B_{i,k}(u)$ 为 $U_{n,k}$ 上的 $k$ 阶(或 $k-1$ 次)`B-spline`基函数

    **·** `deBook-Cox` 递推公式为：

    $B_{i,k}(u)=[\cfrac{u-u_i}{u_{i+k-1}-u_i}]B_{i,k-1}(u)+[\cfrac{u_{i+k}-u}{u_{i+k}-u_{i+1}}]B_{i+1,k-1}(u), \ \ \ \ i=(0,1,2,...,n)$

    $\left \{ \begin{aligned} &当u\in[u_i,u_{i+1}]时，B_{i,1}(u)=1\\&当u\notin[u_i,u_{i+1}]时，B_{i,1}(u)=0 \end{aligned} \right.$

    在上面的递推式中，若遇到 $0/0$ 则取值为 $0$。常称 $u_i$ 为节点，$U_{n,k}$ 为节点向量。若 $u_{j-1}<u_j=u_{j+1} =......= u_ {j+r-1}<u_{j+r} $，则称从 $u_j$ 到 $u_{j+r-1}$ 的每一个节点为 $r$ 重节点

    **·** 已知 $n+1$ 个控制顶点 $\{P_i\}(i=0,1,2,...,n)$ 及参数节点向量：$U_{n,k}=\{u_i\}(i=0,1,2,...,n+k;u_i\leq u_{i+1})$

    称如下形式的参数曲线 $P(u)$ 为 $k$ 阶 $(k-1)$ 次B样条曲线：

    $P(u)=\sum \limits_{i=0}^{n}P_iB_{i,k}(u),u\in [u_{k-1},u_{n+1}]$，其中 $P_i$ 为控制顶点

    **给定 $n+1$ 个控制顶点 $\{P_i\}(i=0,1,2,...,n)$ ，定义一条$k$ 次 $B$ 样条曲线要用到 $n+1$ 个 $k$ 次 $B$ 样条基函数 $B_{i,k}(u)$， 这  $n+1$ 个 $k$ 次 $B$ 样条基函数由节点矢量 $U_{n,k}=\{u_i\}(i=0,1,2,...,n+k)$ 决定。一条 $k$ 次 $B$ 样条曲线段由 $k+1$ 个控制顶点定义，在不含重节点的情况下每增加一个节点，曲线段数就加 $1$，故 $n+1$ 个控制顶点定义的 $k$ 次 $B$ 样条曲线共有 $n-k+1$ 段，曲线定义所对应的节点区间由 $n-k+2$ 个节点组成，共有 $n-k+1$ 个节点区间。**

    **对于四阶曲线来说，顶点 $P_i$ 至多影响定义在区间 $u\in[u_i,u_{i+4}]$ 的曲线段形状，对曲线其他部分的形状不产生影响**

    **·** 三次均匀B样条曲线段的矩阵表示为：

    $P(u)=\frac{1}{6}[u^3 \ \ u^2\ \ u\ \ 1] \left [ \begin{aligned} &-1\ \ \ \ 3\ -3\ \ \ \ 1\\&\ \ \ 3 \ \ \ -6\ \ \ \ 3\ \ \ \ 0\\&-3\ \ \ \ 0\ \ \ \ \ \ 3\ \ \ \ 0\\&\ \ \ 1\ \ \ \ \ \  4\ \ \ \ \ \ 1\ \ \ \ 0\ \ \ \ \end{aligned} \right]\left [ \begin{aligned} P_i \ \\ P_{i+1}\\P_{i+2}\\P_{i+3}\end{aligned} \right]$

    化简后为：

    $\cfrac{1}{6}*[(-u^3+3u^2-3u+1)*P_i+(3u^3-6u^2+4)*P_{i+1}+(-3u^3+3u^2+3u+1)*P_{i+2}+u^3*P_{i+3}]$

    **·** 实现算法时分两层循环，外层是对 `number_of_points` 的循环，即图像总共要绘制多少个点；内层是对节点区间的循环，控制点数量越多区间数量越多。也就是说至少需要四个控制顶点才可以画出图像

    两种曲线绘制结果如下图：（左图为Bezier，右图为B-spline）

    ![image-20221003005823010](C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20221003005823010.png)

  - ==对输入命令的处理==

    在原有基础上新增对 `drawPolygon/Ellipse/Curve translate/rotate/scale/clip` 命令的处理，即将输入的 `string` 分割后提取参数并调用 `cg_algorithms.py` 中的函数绘图

  - ==交互界面不定参数数量的处理方法==

    矩形、曲线的绘制会涉及到不确定数量点的输入，我采用识别鼠标双击事件来确定最后一个点（即画最后一个点时需双击鼠标）

    由于`pyqt`会在识别一次 `mouseDoubleClick` 事件时同时触发两次 `mousePressEvent` 和`mouseReleaseEvent`，所以需删去参数列表中的最后一个参数，即：

    ~~~
    del(self.temp_item.p_list[-1])
    ~~~

    从而使得参数不会重复/冗余

  - ==设置画笔颜色==

    使用了 `QColorDialog` 窗口

    ~~~
    color = QColorDialog.getColor(title = '颜色')
    ~~~

    再通过传参的方式逐级将 `R/G/B` 值传入 `MyItem` 中，为此需要在 `MyCanvas` 类中添加 `self.R/G/B` 三个成员用于储存和更换颜色，这三个成员初值均为 $0$，即黑色

  - ==重置画布==

    使用 `QInputDialog` 获取输入，输入值为画布的宽与高，$width, height \in [100,1000]$，默认值为 $600$

  - ==保存画布==

    本想用 `QPixmap` 中的 `save` 方法保存画布，尝试了多种方法均只能得到黑黑的背景图，于是改用助教给出的使用数组存储像素点并保存至 `.bmp` 文件的方法。画布类自带 `height(),width()` 方法（与重置画布后的长宽一致）；保存文件窗口的调出使用`QFileDialog.getSaveFileName`。

- **以下为GUI操作，操作均需选中图元，且不支持连续操作(例：连续两次平移需选择两次 “编辑-平移”)**

  - ==GUI图元平移==

    在画布任意位置按下鼠标左键即可拖动图元平移

    **·** `mousePressEvent` 记录基准点位置，`mouseMoveEvent` 随时记录变更，`mouseReleaseEvent` 标志一次平移操作的结束

  - ==GUI图元旋转==

    (并没有禁止对椭圆的旋转操作，如有需要可随时修改)

    **·** 需要先按下鼠标左键，这个点会被当作旋转中心，然后再次按下鼠标左键拖动图元旋转（由于QT没有禁止图像被移到画布外，所以我也没有进行特殊处理）

    **·** 为完成旋转设置了类似 $[[-1, -1], [-1, -1], [-1, -1]]$ 的列表，其中 $-1$ 可作为标志使用

    **·** 第一次 `mousePressEvent` 记录 $x,y$ 坐标，第一次 `mouseReleaseEvent` 不做处理

    **·** 第二次 `mousePressEvent` 将 $x+100, y$ 放入第二个列表，`mouseMoveEvent` 将变化的 $x,y$ 放入第三个列表

    **·** 第二次 `mouseReleaseEvent` 之后列表内存储了三个列表，构成三角形(线段)的三个(两个)顶点，此时可用余弦定理求出旋转角度，再判断第三个点的 $y$ 坐标是否大于前两个点 $y$ 坐标，以此判断旋转角度为正或负。以顺时针旋转为正。

  - ==GUI图元缩放==

    没有想到比较合理的方法，最后决定以弹出窗口的方式决定缩放倍数

    **·** 按下鼠标以确定缩放中心，然后会弹出窗口要求输入缩放倍数，倍数 $\in[0.01,100]$

    **·** 仅需要一次 `mousePressEvent` 和 `QInputDialog` 获取输入

  - ==GUI线段裁剪==

    只对线段实现裁剪，对其他图元无效

    **·** 按下鼠标后拖动即可实现裁剪，若裁剪窗口整个在线段之外则无法看到线段

    **·** 第一次 `mousePressEvent` 记录裁剪窗口其中一个对角顶点坐标，`mouseMoveEvent` 随时改变另一个对角顶点坐标

  **上述GUI操作结束后均在mouseReleaseEvent中恢复初始值/状态**

- **2.2 尚未实现内容**

  - 可自己实现的更多功能
  - ...

- **3 联系方式**

  QQ：514121890

  邮箱：514121890@qq.com  或   201220162@smail.nju.edu.cn

- **4 参考资料**

  孙正兴，周良等《计算机图形学教程》，机械工业出版社，2008

  - 技术博客

    [贝塞尔曲线（Bezier Curve）原理及公式推导_CLL_caicai的博客-CSDN博客_三次贝塞尔曲线公式](https://blog.csdn.net/CLL_caicai/article/details/108917480)

    [B样条曲线（B-spline Curves）_余生最年轻的博客-CSDN博客_b样条曲线](https://blog.csdn.net/qq_40597317/article/details/81155571)

    [简单粗暴：B-样条曲线入门 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50626506)

    

- **5 结束语**

  ...

</font>